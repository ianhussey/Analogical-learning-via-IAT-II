---
title: "Screen data"
author: "Ian Hussey"
output:
  html_document:
    highlight: haddock
    toc: yes
---

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(plyr)
library(tidyverse)
library(data.table)

## Set the working directory
setwd("raw/")

# Read all files with the .iqdat extension
files <- list.files(pattern = "\\.csv$")  

# Read these files sequentially into a single data frame
input_df <- dplyr::tbl_df(plyr::rbind.fill(lapply(files, data.table::fread, header = TRUE)))  # tbl_df() requires dplyr, rbind.fill() requires plyr, fread requires data.table
```


```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Make some variable names more transparent
trimmed_df <- 
  input_df %>%
  dplyr::select(subject, # participant
                blocknum,  # block_n
                trialnum,  # trial_n
                blockcode, # task
                trialcode,  # item
                response,  
                correct, # accuracy
                latency,  # rt  
                values.result) %>%  # categorisation of response
  dplyr::rename(participant = subject,
                block_n = blocknum,
                trial_n = trialnum,
                task = blockcode,
                item = trialcode,
                accuracy = correct,
                rt = latency,
                response_categorisation = values.result) %>%
  dplyr::mutate(participant = as.factor(participant))


# complete data per task


## find participants who have data in each task, 
## then for each check if they had data in all the previous tasks
## return those participants who had data in all tasks

##assess what tasks are there - used for the grepl later (as we don't necessarially need to employ all block names)
#tasks <-
#  trimmed_df %>%
#  dplyr::distinct(task)

# no base funciton for mode, so define one
modal_value <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

#separate each tasks and find uniques
participants_with_full_data <- #start with demographics
  trimmed_df %>%
  dplyr::filter(grepl("demographics", task)) %>%  # filter rows where the block_name includes string
  dplyr::distinct(participant)

IAT_and_SCIAT <-
  trimmed_df %>%
  dplyr::filter(grepl("compatibletest", task)) %>%  # filter rows where the block_name includes string
  dplyr::group_by(participant) %>%
  dplyr::summarize(IAT_and_SCIAT_rows = n()) %>%  # count the number of trials per participant
  dplyr::ungroup() %>%
  dplyr::mutate(modal_IAT_and_SCIAT_rows = modal_value(IAT_and_SCIAT_rows)) %>%  # find modal n of trials
  dplyr::rowwise() %>%
  dplyr::filter(IAT_and_SCIAT_rows == modal_IAT_and_SCIAT_rows) %>% # if modal n != n then data is missing or participants has duplicate performance.
  dplyr::select(-modal_IAT_and_SCIAT_rows)

participants_with_full_data <- 
  dplyr::semi_join(participants_with_full_data, IAT_and_SCIAT, by = "participant")


ratings <-
  trimmed_df %>%
  dplyr::filter(grepl("ratings", task)) %>%  # filter rows where the block_name includes string
  dplyr::group_by(participant) %>%
  dplyr::summarize(ratings_rows = n()) %>%  # count the number of trials per participant
  dplyr::ungroup() %>%
  dplyr::mutate(modal_ratings_rows = modal_value(ratings_rows)) %>%  # find modal n of trials
  dplyr::rowwise() %>%
  dplyr::filter(ratings_rows == modal_ratings_rows) %>% # if modal n != n then data is missing or participants has duplicate performance.
  dplyr::select(-modal_ratings_rows)

participants_with_full_data <- 
  dplyr::semi_join(participants_with_full_data, ratings, by = "participant")


modern_racism_scale <-
  trimmed_df %>%
  dplyr::filter(grepl("racism_scale", task)) %>%  # filter rows where the block_name includes string
  dplyr::group_by(participant) %>%
  dplyr::summarize(racism_scale_rows = n()) %>%  # count the number of trials per participant
  dplyr::ungroup() %>%
  dplyr::mutate(modal_racism_scale_rows = modal_value(racism_scale_rows)) %>%  # find modal n of trials
  dplyr::rowwise() %>%
  dplyr::filter(racism_scale_rows == modal_racism_scale_rows) %>% # if modal n != n then data is missing or participants has duplicate performance.
  dplyr::select(-modal_racism_scale_rows)

participants_with_full_data <-
  dplyr::semi_join(participants_with_full_data, modern_racism_scale, by = "participant")


shooter_task <-
  trimmed_df %>%
  dplyr::filter(grepl("POD", task)) %>%  # filter rows where the block_name includes string
  dplyr::group_by(participant) %>%
  dplyr::summarize(shooter_trials = n()) %>%  # count the number of trials per participant
  dplyr::ungroup() %>%
  dplyr::mutate(shooter_trials = modal_value(shooter_trials)) %>%  # find modal n of trials
  dplyr::rowwise() %>%
  dplyr::filter(shooter_trials == shooter_trials) %>% # if modal n != n then data is missing or participants has duplicate performance.
  dplyr::select(-shooter_trials)

participants_with_full_data <-
  dplyr::semi_join(participants_with_full_data, shooter_task, by = "participant")


# participants with at least partial data
participants_with_at_least_partial_data <-
  trimmed_df %>%
  dplyr::distinct(participant) %>%
  dplyr::mutate(participant_partial = participant) 

# participants with incomplete data
participants_with_incomplete_data <-
  dplyr::anti_join(participants_with_at_least_partial_data, participants_with_full_data, by = "participant")


# screened data -----------------------------------------------------------

screened_data <- 
  semi_join(trimmed_df, participants_with_full_data, by = "participant")

screened_data %>% write.csv("screened/screened data.csv", row.names = FALSE)



## produce prolific codes so that participants can be credited or rejected

# 1. prolific codes for participants with complete data so that they can be paid
prolific_codes_for_complete_participants <-
  dplyr::inner_join(trimmed_df, participants_with_full_data, by = "participant") %>%
  dplyr::filter(item == "ProlificCode") %>%
  dplyr::select(participant, response) %>%
  dplyr::distinct(participant, .keep_all = TRUE) 

# participants to credit
prolific_codes_for_complete_participants %>% readr::write_csv("screened/prolific codes - complete data.csv")



# 2. prolific codes for participants with incomplete data so that they can be rejected
prolific_codes_for_incomplete_participants <-
  dplyr::inner_join(trimmed_df, participants_with_incomplete_data, by = "participant") %>%
  dplyr::filter(item == "ProlificCode") %>%
  dplyr::select(participant, response) %>%
  dplyr::distinct(participant, .keep_all = TRUE)

prolific_codes_for_incomplete_participants %>% readr::write_csv("screened/prolific codes - incomplete data.csv")
```

N participants with complete data = `r prolific_codes_for_complete_participants %>% dplyr::summarize(participant = n()) %>% as.integer()`

N participants with incomplete data = `r prolific_codes_for_incomplete_participants %>% dplyr::summarize(participant = n()) %>% as.integer()`
